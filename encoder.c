#include "nu32dip.h"          // constants, funcs for startup and UART
#include "encoder.h"

#define MESSAGE_LENGTH 100
static char mess[MESSAGE_LENGTH]; 
static volatile int encoder_flag = 0;

void ReadUART2(char * message, int maxLength);

void __ISR(_UART_2_VECTOR, IPL7SOFT) InterruptUart2Handler(void) {
  if (IFS1bits.U2RXIF) { // check if interrupt generated by a RX event
    ReadUART2(mess, 100);
    //NU32DIP_WriteUART1(mess);
    encoder_flag = 1;
    IFS1bits.U2RXIF = 0; // clear the RX interrupt flag
  } 
  else if(IFS1bits.U2TXIF) { // if it is a 

  } 
  else if(IFS1bits.U2EIF) { // if it is an error interrupt. check U3STA for reason 

  }
}

void UART2_Startup() {
    __builtin_disable_interrupts(); // disable interrupts while initializing things

    //UART2 pins
    U2RXRbits.U2RXR = 0b0011;     //setting RB11 as U2RX
    RPB0Rbits.RPB0R = 0b0010;     //setting RB0 as U2TX

    // turn on UART1 without an interrupt CHANGE!!!
    U2MODEbits.BRGH = 0; // set baud to NU32_DESIRED_BAUD
    U2BRG = ((NU32DIP_SYS_FREQ / NU32DIP_DESIRED_BAUD) / 16) - 1;

    // 8 bit, no parity bit, and 1 stop bit (8N1 setup)
    U2MODEbits.PDSEL = 0;
    U2MODEbits.STSEL = 0;

    // configure TX & RX pins as output & input pins
    U2STAbits.URXEN = 1;          //enable receive
    U2STAbits.UTXEN = 1;          //enable transmit
    // configure without hardware flow control
    U2MODEbits.UEN = 0;

    U2STAbits.URXISEL = 0x0;    // RX interrupt when receive buffer not empty
    IFS1bits.U2RXIF = 0;        // clear the rx interrupt flag. for
                                // tx or error interrupts you would also need to clear
                                // the respective flags

    IPC9bits.U2IP = 7;          // interrupt priority 7
    IEC1bits.U2RXIE = 1;        // enable the RX interrupt

    // enable the uart
    U2MODEbits.ON = 1;

    __builtin_enable_interrupts();
}

void WriteUART2(const char * string) {
    while (*string != '\0') {
        while (U2STAbits.UTXBF) {
            ; // wait until tx buffer isn't full
        }
        U2TXREG = *string;
        ++string;
    }
}


int get_encoder_count(){
    WriteUART2("a");
    while(!get_encoder_flag()){
        ; // wait for the Pico to respond
    } 
    set_encoder_flag(0); // clear the flag so you can read again later
    int encode_count;
    sscanf(mess, "%d", &encode_count);
    return encode_count;
    
}

int get_encoder_flag(){
  return encoder_flag;
}

void set_encoder_flag(int set){
  encoder_flag = set;
}

void reset_encoder(){
    WriteUART2("b");
}

float get_encoder_degrees() {
    int encoder_count = get_encoder_count();
    float encoder_degrees = encoder_count/9.3333333;
    return encoder_degrees;
}

void ReadUART2(char * message1, int maxLength) {
    char data = 0;
    int complete = 0, num_bytes = 0;
    // loop until you get a '\r' or '\n'
    while (!complete) {
        if (U2STAbits.URXDA) { // if data is available
            data = U2RXREG; // read the data
            if ((data == '\n') || (data == '\r')) {
                complete = 1;
            } else {
                message1[num_bytes] = data;
                ++num_bytes;
                // roll over if the array is too small
                if (num_bytes >= maxLength) {
                    num_bytes = 0;
                }
            }
        }
    }
    // end the string
    message1[num_bytes] = '\0';
}